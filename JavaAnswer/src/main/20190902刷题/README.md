# 2019-09-02 刷题错题集
## 不定项选择题
1."hello" instanceof Object 的返回值是 **true**<br>

> 错误选项：String

```markdown
instanceof 是 Java 语言中的一个二元运算符，它的作用是判断一个引用类型的变量所指向的对象是否为一个类的实例，
即它左边的对象是否在它右边的类的实例，返回的是**boolean**类型的数据，一般是相同类型返回 true；不是相同类型或 null 则返回 false
```

2.有关于方法覆盖的描述正确的是：要求覆盖和被覆盖的方法必须具有相同的访问权限

> 错误选项：1) 覆盖的方法不能比被覆盖的方法抛出更多的异常 2) 要求覆盖和被覆盖的方法具有相同的名字、参数列表以及返回值

```markdown
覆盖是指派生类方法覆盖基类方法，覆盖一个方法并对其重写，以起到不同的作用，需注意：<br>
1) 派生类中的覆盖方法必须要和基类中被覆盖的方法具有**相同的函数名和参数**<br>
2) 派生类中的覆盖方法的返回值必须和基类中被覆盖的方法的**返回值相同**<br>
3) 基类中被覆盖的方法**不能为private**，否则其子类只能定义了另外一个方法，并没有对其覆盖<br>
4) 派生类的方法**不能缩小**基类的**访问权限**<br>
5) 派生类的方法**不能抛出**比基类的更多的异常
```

3.下面说法正确的是：如果源代码中有 package 语句，则该语句必须被放在代码的第一行(不考虑注释和空格)

```markdown
package 是Java语言特有的内容，它的作用就是把若干类按包结构进行分类管理，
最重要用途是为了解决同名但作用不同的类型存在的问题；

import 语句允许开发人员在编译时将其他类的源代码包含在源文件中，具体而言，
import 语句包括 import 关键字，以"."号分隔的包路径、类名和星号"*"；需注意的是每一条 import 语句只对应一个包；

在 Java 语言中，package 语句必须作为 Java 源文件的第一句语句，指明该文件中定义的类所在的包；所以如果代码中有 package 语句则必须放在最前面，即该语句必须放在代码的第一行(不考虑注释和空格)；

```

4.下面的变量名合法的有：var2、_var、_1_、$var

> 错误选项：#var

5.一个 Java 程序运行从上到下的环境依次是：Java程序、JRE/JVM、操作系统、硬件

```markdown
Java程序被编译后并不是能在硬件平台上可执行的代码，而是生成了一个中间代码；不同的硬件平台上会安装有
不同的 JVM ，由 JVM 来负责把中间代码翻译成硬件平台能执行的代码；JVM不具有平台独立性，与硬件平台是相关的；

Java 程序的下一层为 JVM，而 JVM 是运行在操作系统上的，操作系统又运行在硬件上；因此一个 Java 程序运行的环境
次序是从上到下是 Java 程序、JRE/JVM、操作系统、硬件
```

6.下面关键字，可以用来修饰接口中的变量是：static

```markdown
Java接口是一系列方法的声明，是一些方法特征的集合；一个接口只有方法的声明，但没有方法实现(JDK8以前)；因此这些方法可以
在不同的地方被不同的类实现，而这些实现可以具有不同的行为；通常接口中定义的成员变量默认为**public static final**，只能够
有静态的不能被修改的数据成员，而且必须将其赋初值，其所有的成员变量都是public、abstract的，而且只能被这两个关键字修饰
```

7.有如下代码：
```java
String s = "xbcde";
System.out.println(s.charA.t(4));
```
上述代码段的描述是：代码编译不成功，因为 charA.t() 方法不属于 String 类

```markdown
在Java语言中，String 是一个特殊的包装类数据，该题目中 String 并不存在这个方法

正确的方法时**charAt(int index)**，是一个能够用来检索特定索引下的字符的方法，该方法返回索引位置的 char 值
```

8.创建 Map 集合的方式中，正确的是：Map 是接口，所以不能实例化

```markdown
Java 为数据结构中的映射定义了一个接口 java.util.Map，它有三个实现类：HashMap、HashTable、TreeMap；由于接口中的方法
都没有实现，因此不能直接使用 new 来实例化一个接口，因为 new 只能用来实例化非抽象的类
```

9.关于被访问控制符 protected 修饰的成员变量的描述中：可以被三种类所引用：该类自身、与它在同一包中的其他类、在其他包中的该类的子类

10.为了区分类中的重载的同名的不同方法，要求：采用不同的形式参数列表

```markdown
重载是一个类中多态性的一种表现，是指在一个类中定义了多个同名的方法，它们或有**不同的参数个数**，或有**不同的参数类型**，在使用重载需注意：<br>
1) 重载是通过不同的参数来区分的：不同的参数个数、不同的参数类型或不同的参数顺序
2) 不能通过方法的访问权限、返回值类型和抛出的异常类型来进行重载
```

11.对于构造方法的描述中，正确的是：构造方法名与类名必须相同

> 错误选项：构造方法可以被程序调用

```markdown
构造方法是一种特殊的方法，主要用来创建对象时初始化对象，即为对象成员变量赋初始值；<br>
1) 构造方法必须与类的名字相同，并且不能有返回值<br>
2) 构造方法是在对象被创建的时候由编译器调用的，程序无法直接调用构造方法 
3) 如果没有提供构造方法，编译器会提供以默认的构造方法

```

12.关于继承的描述：子类能继承父类的非私有方法和属性

> 错误选项：子类只能继承父类的公有方法和属性

```markdown
继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能提供新的能力，
子类能继承父类的公有和受保护的方法和属性，但是不能继承私有方法和属性
```

13.关于类继承父类构造方法的描述：子类无法继承父类的构造方法

> 错误选项：子类必须通过 super 关键字调用父类的构造方法

```markdown
1) 当创建子类对象的时候，必定会调用父类的构造方法，然后再调用子类的构造方法
2) 构造方法是不能被继承的
3) 当子类没有显示地调用构造方法的时候，编译器会自动调用父类的无参构造方法
4) 子类不能通过super()方法调用父类的构造方法
```

14.关于Java语言基础知识：类是方法和变量的集合体

```markdown
1) 类可以理解为变量和方法的集合体
2) 抽象类是不能被实例化的，只有实现了抽象类的具体类才能被实例化
3) 接口不能被实例化，只有实现了接口方法的类才能被实例化
4) 数组是一些相同数据类型的集合，请注意"相同"这个字眼
5) 类的数据类型可以是公开的，也可以是私有的，由于面向对象封装的思想
   都会将其设计为私有的，并提供公有的访问方法
```

15.有如下代码：
```java
public class Question15 {
    public static void main(String[] args) {
        class A {
            public int i = 3;
        }
        Object o = (Object)new A();
        A a = (A)o;
        System.out.println("i = " + a.i);
    }
}
```
运行的结果为：i = 3

> 错误选项：编译失败

```markdown
类 A 是 main() 方法内部的一个内部类，执行 new A() 的时候初始化了一个 A 的对象，这个对象的属性 i 的值为 3 
经过类型转换后，最后 a 是这个对象的引用，因此输出结果为 i = 3；
```

## 填空题
16.用于声明一个类为抽象类的关键字是**abstract**，用于将一个类修饰为最终类的关键字是**final**<br>
17.构造方法，成员变量初始化以及静态成员变量初始化三者的先后顺序是：**静态成员变量**、**成员变量初始化**、**构造方法**<br>

```markdown
Java程序的初始化一般遵循以下三个原则：<br>
1) 静态变量优先于非静态变量初始化，其中静态变量只初始化一次，非静态变量可以初始化多次
2) 父类优先于子类进行初始化
3) 按照成员变量定义顺序进行初始化，即使变量定义散布于方法定义之中，
   它们依然在任何方法被调用之前先初始化

它们的执行的顺序是：父类静态变量 >> 父类静态代码块 >> 子类静态变量 >> 
子类静态代码块 >> 父类非静态变量 >> 父类非静态代码块 >> 父类构造方法 >> 
子类非静态变量 >> 子类非静态代码块 >> 子类构造方法

```

18.在 Java 语言中的基本数据类型中，字符型、整型分别占用字节数为**2**、**4**<br>
19.一般有两种用于创建线程对象的方法，分别为**继承Thread类**、**实现Runnable接口**<br>
20.Java语言提供了两种用于多态的机制，分别是**重载**和**重写**

## 简答题
1.接口是否继承接口？抽象类是否可实现(implements)接口？抽象类是否能继承实体类？<br>
接口可以继承接口，并且可以多继承接口；<br>
抽象类可以实现接口；<br>
抽象类可以继承实体类；<br>

2.面向对象的特征有哪些方面？<br>
**抽象**：忽略当前一个主题与当前目标无关的哪些方面，以便更加充分地注重与当前目标有关的方面，抽象并打算了解全部问题，
而只是选择其中的一部分，暂时不用关注细节。抽象包括两方面：过程抽象和数据抽象<br>

**封装**：指将客观事物抽象成类，每个类对自身的数据和方法实现保护，类可以把自己的数据和方法只让可信的类或者对象操作，
对不可信的进行隐藏<br>

**继承**：继承是一种联结类的层次模型，允许和鼓励类的重用，提供了一种明确表达共性的方法；对象的一个新类可以从现有的
类中派生出来，这个过程称为类继承；在Java语言中，新类继承了原始类的非私有属性和方法，并且可修改或增加方法使其更适合特殊的情况<br>

**多态**：指允许不同类的对象对同一消息作出响应，在Java语言中多态表现为对子父类之间的同名方法的正确处理(重载和重写)<br>

3.String 和 StringBuffer 有什么区别？<br>
String 用于操作字符串，属于不可变类；而 StringBuffer 也是用于字符串操作，属于可变类<br>
如果一个字符串需要被修改的时候，使用 StringBuffer 更具有效率<br>

4.final、finally 和 finalize 的区别是什么？<br>
final 用于声明属性、方法和类，分别表现属于不可变、方法不可覆盖、类不可变继承；<br>
finally 作为一场处理的一部分，只能用于 try-catch 语句中，并且附带着一个语句块，表示这段代码最终一定会执行，经常被用来需要释放资源的时候<br>
finalize 是 Object 类的一个方法，在垃圾收集器执行的时候回调用被回收对象的 finalize()，可以覆盖此方法来实现对其他资源的回收<br>

5.ArrayList、Vector 和 LinkedList 有什么特点？
ArrayList 是基于数组实现的动态可变数组集合，在内存中是连续的地址空间，特点会表现在改查快而增删慢；<br>
LinkedList 是基于链表实现的线性集合，在内存中是不连续的地址空间并通过节点进行连接，特点会表现在增删快而查询慢；<br>
Vector 是线程安全的 ArrayList ，性能上会比 ArrayList 差；<br>

## 附加题
1.编写一个截取字符串的函数，输入一个字符串和字节数，输出为按字节截取的字符串，但是要保证汉子不能被截半个，如"人ABC"4，
应该截为"人AB"，输入"人ABC们DEF"，6，应该输出为"人ABC"，而不是"人ABC + 们的半个"<br>

2.排序有哪几种方法？用 Java 语言实现一个插入排序？







