# 单例模式思想
		
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点；
		
为什么使用单例？

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。
事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。
		
使用单例的好处：
- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
- 由于new的操作次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间
		
为什么不适用全局变量确保一个类只有一个实例？

我们知道全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。
只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。  
但是，如果说这个对象非常消耗资源，而且程序某次的执行中一直没用，这样就造成了资源的浪费。
利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。 
不仅仅是因为这个原因，在程序中我们要尽量避免全局变量的使用，大量使用全局变量给程序的调试、维护等带来困难。

## 单例模式的实现
	
有两种构建方法：
- 饿汉方式：指全局的单例实例在类装载时构建
- 懒汉方式：指全局的单例在第一次使用时构建
		
不管哪种创建方式，它们通常有下面几个相似点：		
- 单例类必须要有一个private访问级别的构造函数，才能确保单例不会在系统中其他代码内被实例化
- instance成员变量和uniqueInstance方法必须是static的
		
## 单例模式实例
	
有五种不同的创建情况，视情况而创建
		
- 饿汉方式(线程安全）
- 懒汉式（非线程安全和synchronized关键字线程安全版本)
- 懒汉式(双重检查加锁版本)
- 饿汉式（枚举方式）
			